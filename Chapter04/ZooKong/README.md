## 아키텍처

### `전체 구조`

- MySQL 서버는 MySQL 엔진과 스토리지 엔진으로 구분
  - MySQL은 일반 상용 RDBMS와 같이 대부분 프로그래밍 언어로부터 접근 지원 
  - MySQL 엔진
    - 사람의 머리 역할과 흡사
    - 요청을 처리하는 커넥션 핸들러, SQL 파서 및 전처리기, 옴티마이저 등으로 구성 
  - 스토리지 엔진
    - 손과 발의 역할과 흡사
    - 실제 데이터를 디스크 스토리지에 저장하거나 읽어오는 부분을 전담
    - MySQL 엔진은 하나이지만 스토리지 엔진은 여러개 동시에 사용 가능
      - ``` mysql> CREATE TABLE test_table (…) ENGINE=INNODB; ```
      - test_table 테이블에 대해 DML 요청 시에 InnoDB 스토리지 엔진이 처리 담당
  - 핸들러 API
    - MySQL 엔진의 쿼리 실행을 위해 스토리지 엔진에게 요청을 함
    - 이러한 요청을 핸들러 요청이라 함, 여기서 사용되는 API를 핸들러 API라고 함
    - 핸들러 API를 통해 얼마나 많은 데이터 작업이 있는지 확인 가능
      - ``` mysql> SHOW GLOBAL STATUS LIKE 'Handler%'; ```

### `스레딩 구조`

- 프로세스 기반이 아닌 스레드 기반으로 작동
- 스레드는 크겍 포그라운드, 백그라운드 스레드로 구분
  - performance_schema DB에 threads 테이블을 통해 실행 중인 스레드 확인 가능
- 백그라운드 스레드의 개수는 서버 설정으로 변경 가능
  - innodb_read_io_threads, innodb_write_io_threads

#### 포그라운드 스레드

- 최소한 MySQL 서버에 접속된 클라언트의 수만큼 존재
- 주로 각 클라이언트가 요청하는 쿼리 문장 처리
- 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시로 되돌아 감
  - thread_cache_size에 설정된 값보다 많은 스레드가 있을 경우 스레드를 캐시에 돌려놓지 않고 종료
- 데이터를 MySQL의 데이터 버퍼나 캐시로부터 조회, 없을 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와 작업 처리
- 디스크 쓰기 작업은 MyISAM 엔진의 경우 포그라운드 스레드가 처리, InnoDB 엔진은 데이터 버퍼나 캐시까지만 포그라운드가 처리 후 디스크 기록은 백그라운드 스레드가 처리
  - MyISAM도 지연된 쓰기가 존재는하나 일반적인 방법은 아님
  
#### 백그라운드 스레드

- MyISAM는 별로 해당되지는 않지만 InnoDB의 백그라운드 처리 항목
  - 인서트 버퍼를 병합하는 스레드
  - 로그를 디스크로 기록하는 스레드
  - InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
  - 데이터를 버퍼로 읽어 오는 스레드
  - 잠금이나 데드락을 모니터링하는 스레드
- 주로 읽는 작업은 클라이언트 스레드에서 처리되기 때문에 innodb_read_io_threads 는 많이 설정할 필요가 없음
- 쓰기 작업은 백그라운드에서 많이 처리
- 사용자 요청 처리중에는 데이터 쓰기 작업은 지연 처리가 될 수 있지만 읽기 작업은 절대 지연될 수 없음
  - 일반적으로 DBMS는 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 탑재, InnoDB도 같은 방식
    - 디스크에 데이터 파일이 적용까지 기다릴 필요가 없음
  - MyISAM는 포그라운드 스레드가 쓰기 작업까지 함께 처리
    - 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없음

> MyISAM에서 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다고 하였는데 그럼 언제 사용할 수 있을까?

### `메모리 할당 및 사용 구조`

- 크게 글로벌, 로컬 메모리 영역으로 구분

#### 글로벌 메모리 영역

- MySQL 서버가 시작되면서 운영체제로부터 할당
  - 정확히 할당된 메모리 확인이 쉽지 않아 시스템 변수로 설정한 만큼 할당받는다고 생각
  
> MySQL 서버의 메모리 할당과 관련된 시스템 변수는 무엇이 있을까?

- 일반적으로 클라언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당
  - 필요에 따라 2개 이상의 메모리 공간을 할당받을 수 있음
  - 대표적인 글로벌 메모리 영역
    - 테이블 캐시
    - InnoDB 버퍼 풀
    - InnoDB 어댑티브 해시 인덱스
    - InnoDB 리두 로그 버퍼

> 2개 이상의 메모리 공간을 할당받을 이유와 상황이 무엇일까?
> InnoDB 언두 로그 버퍼가 있을까?

#### 로컬 메모리 영역 (다시 읽어보기)

- 세션 메모리 영역이라고도 표현
- 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역
- 각 클라언트 스레드별로 독립적으로 할당, 공유되지 않음
- 가능성은 희박하지만 MySQL 서버가 메모리 부족으로 멈춰 버릴 수 있음, 그러나 일반적으로 소트 버퍼와 같은 로컬 메모리 영역은 크게 신경쓰지 않음
- 대표적인 로컬 메모리 영역
  - 정렬 버퍼
  - 조인 버퍼
  - 바이너리 로그 캐시
  - 네트워크 버퍼

### ```플러그인 스토리지 엔진 모델```

- 플러그인 모델은 MySQL의 독특한 특징 중 하나
- 스토리지 엔진, 검색어 파서 등에 대해 플러그인해서 사용 가능, 게다가 사용자의 인증을 위한 Native Authentication 등도 모두 플러그인
  - 직접 스토리지 엔진을 개발하는 것도 가능
- 쿼리 실행에 있어서 대부분의 작업이 MySQL 엔진에서 처리, 마지막 "읽기/쓰기" 작업만 스토리지 엔진에서 처리
  - 이는 스토리지 엔진을 만든다 하더라도 전체 기능이 아닌 일부를 개발한다는 의미
- MySQL 엔진이 각 스토리지 엔진에게 데이터를 읽고/쓰기 위해서는 반드시 핸들러를 통해야 함
- 스토리지 엔진이 다르더라도 MySQL의 처리 내용은 대부분 동일, 스토리지 엔진 담당인 읽기/쓰기 영역의 처리만 차이
- 실직적으로 GROUP BY나 ORDER BY 등 복잡한 처리는 MySQL 엔진의 '쿼리 실행기'에서 처리

> GROUP BY나 ORDER BY의 경우 MySQL 엔진 부분에서 제어가 된다면 많은 양의 데이터를 수행하기 위해서는 메모리가 많이 필요하지 않을까?

``` 
# 지원되는 스토리지 엔진 확인
mysql> SHOW ENGINES;
```

- 포함되지 않은 스토리지 엔진을 사용하려면 서버를 다시 빌드(컴파일) 필요
- 적절한 준비만 돼 있다면 플러그인 형태로 빌드된 스토리지 엔진 라이브러리를 다운로드해서 끼워 넣기만 하면 사용 가능
- 플러그인 형태의 스토리지 엔진은 손쉽게 업그레이드 가능

```
# 서버의 플러그인 확인
mysql> SHOW PLUGINS;
```

> 플러그인 형태로 라이브러리를 다운로드해서 끼워 넣으면 사용 가능하다고 하는데.. 적절한 준비는 무슨 준비일까?

### ```컴포넌트```

- 8.0에서 기존 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처 지원
- 기존 플러그인 아키텍처 단점
  - 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신할 수 없음
  - MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음
  - 상호 의존 관계를 설정할 수 없어서 초기화 어려움
- 비밀번호 검증에 대해 5.7은 플러그인, 8.0은 컴포넌트로 개선
- 컴포넌트도 플러인과 마찬가지로 설치하면 새로운 시스템 변수를 설정해야 할 수 있어 메뉴얼을 확인해야 함
  
> 플로그인과 컴포넌트는 내부적으로 어떤 구조적 차이가 있을까?

### `쿼리 실행 구조`
 
- 쿼리 실행 순서 : 쿼리 파서 -> 전처리기 -> 옵티마이저 -> 실행 엔진(실행기) -> 스토리지 엔진(핸들러)
  - 쿼리 파서
    - 사용자 요청 쿼리를 토큰으로 분리 후 트리 형태 구조로 변환, 파서 트리 생성
    - 쿼리 문장의 기본 문법 오류 검사
  - 전처리기
    - 파서 트리를 기반으로 문장에 구조적 문제점 확인
    - 각 토큰에 대해 테이블 이름, 칼럼 이름, 내장 함수 등의 객체 존재 여부 등 확인
    - 접근 권한 등 확인
  - 옵티마이저
    - 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정
    - DBMS의 두뇌에 해당
  - 실행 엔진
    - 작업 처리 계획대로 각 핸들러에게 요청
    - 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할 수행
  - 스토리지 엔진(핸들러)
    - MySQL 서버의 가장 밑단에서 실행 엔진의 요청에 따라 데이터를 읽기/쓰기 역할 담당
    - InnoDB 테이블을 조작하는 경우 핸들러가 InnoDB 스토리지 엔진임

### `복제` (16장 읽기)

- 16장 복제

### `쿼리 캐시`

- 빠른 응답을 위해 필요
  - 특히 웹 기반의 응용 프로그램에서 매우 중요한 역할
- 실행 결과를 메모리에 캐시하고 동일 SQL 쿼리에 대해 테이블을 읽지 않고 즉시 결과를 반환
- 쿼리 캐시 단점
  - 테이블 데이터 변경으로 인해 관련 캐시를 삭제, 심각한 동시 처리 성능 저하 유발
  - 많은 버그의 원인 되기도 했음
- 8.0 부터는 쿼리 캐시 기능 및 관련 시스템 변수 모두 제거
- 데이터 변경은 거의 없고 읽기만 하는 서비스는 흔치 않아 실제 큰 도움이 됐던 서비스는 거의 없음, 버그가 더 큰 영향

> 쿼리 캐시의 단점 중에 많은 버그가 존재했다고 하였는데 어떤 이유에서 발생한 것일까?

### `스레드 풀`

- 엔터프라이즈 에디션은 스레드 풀 기능 제공
- 커뮤니티는 Percona Server에 플러그인 형태의 스레드 풀 라이브러리를 설치하여 사용 가능
- 사용자의 요청을 처리하는 스레드 개수를 제한하고 CPU가 제한된 스레드 처리에만 집중하여 서버의 자원 소모를 줄이는 것이 목적
- CPU가 잘 처리해낼 수 있는 수준으로 스레드를 줄여서 빨리 처리하게 하는 것이 핵심

